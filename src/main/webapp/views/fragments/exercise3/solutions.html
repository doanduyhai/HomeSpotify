<div class="row">
    <h3>The solution</h3>
    <tabset>
        <tab heading="Scala">
<pre><code class="scala">
val sc = buildSparkContext(EXERCISE_3)

/*
 * Read data from 'performers_distribution_by_style' table
 */
val artists:CassandraRDD[(String,String,Int)] = sc
    .cassandraTable(KEYSPACE, PERFORMERS_DISTRIBUTION_BY_STYLE)
    .select("type","style","count")
    .as((_:String,_:String,_:Int))

val sortedPerformers:RDD[(String,String,Int)] = artists
    .filter {case (_,style,_) => style != "Unknown"}
    .sortBy[Int](tuple => tuple._3,false,1)

// Put the sorted RDD in cache for re-use
sortedPerformers.cache()

// Extract styles for groups
val groupsStyles: RDD[(String, String, Int)] = sortedPerformers
    .filter {case(performer_type,_,_) => performer_type == "group"}

// Extract styles for artists
val artistStyles: RDD[(String, String, Int)] = sortedPerformers
    .filter {case(performer_type,_,_) => performer_type == "artist"}

// Cache the groupStyles
groupsStyles.cache()

// Cache the artistStyles
artistStyles.cache()

// Count total number of artists having styles that are not in the top 10
val otherStylesCountForGroup:Int = groupsStyles
    .collect()  //Fetch the whole RDD back to driver program
    .drop(10) //Drop the first 10 top styles
    .map{case(_,_,count)=>count} //Extract the count
    .sum //Sum up the count

// Count total number of groups having styles that are not in the top 10
val otherStylesCountForArtist:Int = artistStyles
    .collect() //Fetch the whole RDD back to driver program
    .drop(10) //Drop the first 10 top styles
    .map{case(_,_,count)=>count} //Extract the count
    .sum //Sum up the count


// Take the top 10 styles for groups, with a count for all other styles
val top10Groups = groupsStyles.take(10) :+ ("group","Others",otherStylesCountForGroup)

// Take the top 10 styles for artists, with a count for all other styles
val top10Artists = artistStyles.take(10) :+ ("artist","Others",otherStylesCountForArtist)

/*
 * Remark: by calling take(n), all the data are shipped back to the driver program
 * the output of take(n) is no longer an RDD but a simple Scala collection
 */

// Merge both list and save back to Cassandra
sc.parallelize(top10Artists.toList ::: top10Groups.toList)
    .saveToCassandra(KEYSPACE,TOP_10_STYLES,SomeColumns("type","style","count"))

</code></pre>
        </tab>
        <tab heading="Java 8">
<pre><code class="java">
JavaSparkContext sc = buildSparkContext(EXERCISE_3);

/*
 * Read data from 'performers_distribution_by_style' table
 * and map to the PerformerDistributionByStyle POJO
 */
JavaRDD&lt;PerformerDistributionByStyle&gt; rows = javaFunctions(sc)
    .cassandraTable(KEYSPACE, PERFORMERS_DISTRIBUTION_BY_STYLE)
    .select("type", "style", "count")
    .map(row -> new PerformerDistributionByStyle(row.getString("type"),
            row.getString("style"),
            row.getInt("count")));


JavaRDD&lt;PerformerDistributionByStyle&gt; sortedPerformerDistribution = rows
    .filter(p -> !p.getStyle().equals("Unknown")) //Filter out the 'Unknown' style
    .sortBy(p -> p.getCount(), false, 1); //Sort by count, highest count fist

// Put the sorted RDD in cache for re-use
sortedPerformerDistribution.cache();

// Extract styles for groups
final JavaRDD&lt;PerformerDistributionByStyle&gt; groupStyles = sortedPerformerDistribution
    .filter(bean -> bean.getType().equals("group")); //Take only 'group' type

// Extract styles for artists
final JavaRDD&lt;PerformerDistributionByStyle&gt; artistStyles = sortedPerformerDistribution
    .filter(bean -> bean.getType().equals("artist")); //Take only 'artist' type

// Cache the groupStyles
groupStyles.cache();

// Cache the artistStyles
artistStyles.cache();

// Count total number of artists having styles that are not in the top 10
final int otherStylesCountForGroup = groupStyles
    .collect() //Fetch the whole RDD back to driver program
    .stream()
    .skip(10) //Drop the first 10 top styles
    .mapToInt(bean -> bean.getCount()) //Extract the count
    .sum();

// Count total number of groups having styles that are not in the top 10
final int otherStylesCountForArtist = artistStyles
    .collect() //Fetch the whole RDD back to driver program
    .stream()
    .skip(10) //Drop the first 10 top styles
    .mapToInt(bean -> bean.getCount()) //Extract the count
    .sum();


// Take the top 10 styles for groups, with a count for all other styles
final List&lt;PerformerDistributionByStyle&gt; top10Groups = groupStyles.take(10);
top10Groups.add(new PerformerDistributionByStyle("group", "Others", otherStylesCountForGroup));

// Take the top 10 styles for artists, with a count for all other styles
final List&lt;PerformerDistributionByStyle&gt; top10Artists = artistStyles.take(10);
top10Artists.add(new PerformerDistributionByStyle("artist", "Others", otherStylesCountForArtist));


/*
 * Remark: by calling take(n), all the data are shipped back to the driver program
 * the output of take(n) is no longer an RDD but a simple Java collection
 */

// Merge both top10 lists
JavaRDD&lt;PerformerDistributionByStyle&gt; merged = sc.parallelize(top10Artists)
    .union(sc.parallelize(top10Groups));

// Save back to Cassandra
javaFunctions(merged)
    .writerBuilder(KEYSPACE, TOP_10_STYLES,
        CassandraJavaUtil.mapToRow(PerformerDistributionByStyle.class))
    .saveToCassandra();

</code></pre>
        </tab>
    </tabset>

</div>